import{_ as a,c as s,d as n,o as t}from"./app-YtdSVBp9.js";const p={};function o(l,e){return t(),s("div",null,e[0]||(e[0]=[n(`<h1 id="json-web-token-入门教程" tabindex="-1"><a class="header-anchor" href="#json-web-token-入门教程"><span>JSON Web Token 入门教程</span></a></h1><p>作者： <a href="http://www.ruanyifeng.com/" target="_blank" rel="noopener noreferrer">阮一峰</a></p><p>日期： <a href="http://www.ruanyifeng.com/blog/2018/07/" target="_blank" rel="noopener noreferrer">2018 年 7 月 23 日</a></p><p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案，本文介绍它的原理和用法。</p><p><img src="https://cdn.beekka.com/blogimg/asset/201807/bg2018072301.jpg" alt="img"></p><h2 id="一、跨域认证的问题" tabindex="-1"><a class="header-anchor" href="#一、跨域认证的问题"><span>一、跨域认证的问题</span></a></h2><p>互联网服务离不开用户认证。一般流程是下面这样。</p><blockquote><p>1、用户向服务器发送用户名和密码。</p><p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p><p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p><p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p><p>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p></blockquote><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><h2 id="二、jwt-的原理" tabindex="-1"><a class="header-anchor" href="#二、jwt-的原理"><span>二、JWT 的原理</span></a></h2><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><blockquote><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token punctuation">{</span></span>
<span class="line">  <span class="token string-property property">&quot;姓名&quot;</span><span class="token operator">:</span> <span class="token string">&quot;张三&quot;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token string-property property">&quot;角色&quot;</span><span class="token operator">:</span> <span class="token string">&quot;管理员&quot;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token string-property property">&quot;到期时间&quot;</span><span class="token operator">:</span> <span class="token string">&quot;2018年7月1日0点0分&quot;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h2 id="三、jwt-的数据结构" tabindex="-1"><a class="header-anchor" href="#三、jwt-的数据结构"><span>三、JWT 的数据结构</span></a></h2><p>实际的 JWT 大概就像下面这样。</p><p><img src="https://cdn.beekka.com/blogimg/asset/201807/bg2018072304.jpg" alt="img"></p><p>它是一个很长的字符串，中间用点（<code>.</code>）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分依次如下。</p><blockquote><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul></blockquote><p>写成一行，就是下面的样子。</p><blockquote><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line">Header<span class="token punctuation">.</span>Payload<span class="token punctuation">.</span>Signature<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></blockquote><p><img src="https://cdn.beekka.com/blogimg/asset/201807/bg2018072303.jpg" alt="img"></p><p>下面依次介绍这三个部分。</p><h3 id="_3-1-header" tabindex="-1"><a class="header-anchor" href="#_3-1-header"><span>3.1 Header</span></a></h3><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p><blockquote><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token punctuation">{</span></span>
<span class="line">  <span class="token string-property property">&quot;alg&quot;</span><span class="token operator">:</span> <span class="token string">&quot;HS256&quot;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token string-property property">&quot;typ&quot;</span><span class="token operator">:</span> <span class="token string">&quot;JWT&quot;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p>上面代码中，<code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为<code>JWT</code>。</p><p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p><h3 id="_3-2-payload" tabindex="-1"><a class="header-anchor" href="#_3-2-payload"><span>3.2 Payload</span></a></h3><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了 7 个官方字段，供选用。</p><blockquote><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul></blockquote><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><blockquote><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token punctuation">{</span></span>
<span class="line">  <span class="token string-property property">&quot;sub&quot;</span><span class="token operator">:</span> <span class="token string">&quot;1234567890&quot;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token string-property property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;John Doe&quot;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token string-property property">&quot;admin&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><h3 id="_3-3-signature" tabindex="-1"><a class="header-anchor" href="#_3-3-signature"><span>3.3 Signature</span></a></h3><p>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><blockquote><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token constant">HMACSHA256</span><span class="token punctuation">(</span><span class="token function">base64UrlEncode</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;.&quot;</span> <span class="token operator">+</span> <span class="token function">base64UrlEncode</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">,</span> secret<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></blockquote><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用&quot;点&quot;（<code>.</code>）分隔，就可以返回给用户。</p><h3 id="_3-4-base64url" tabindex="-1"><a class="header-anchor" href="#_3-4-base64url"><span>3.4 Base64URL</span></a></h3><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p><h2 id="四、jwt-的使用方式" tabindex="-1"><a class="header-anchor" href="#四、jwt-的使用方式"><span>四、JWT 的使用方式</span></a></h2><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息<code>Authorization</code>字段里面。</p><blockquote><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token literal-property property">Authorization</span><span class="token operator">:</span> Bearer <span class="token operator">&lt;</span>token<span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></blockquote><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><h2 id="五、jwt-的几个特点" tabindex="-1"><a class="header-anchor" href="#五、jwt-的几个特点"><span>五、JWT 的几个特点</span></a></h2><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p><p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p><p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p><p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p><p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p><p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p><h2 id="六、参考链接" tabindex="-1"><a class="header-anchor" href="#六、参考链接"><span>六、参考链接</span></a></h2><ul><li><a href="https://jwt.io/introduction/" target="_blank" rel="noopener noreferrer">Introduction to JSON Web Tokens</a>， by Auth0</li><li><a href="https://medium.com/@bryanmanuele/sessionless-authentication-withe-jwts-with-node-express-passport-js-69b059e4b22c" target="_blank" rel="noopener noreferrer">Sessionless Authentication using JWTs (with Node + Express + Passport JS)</a>, by Bryan Manuele</li><li><a href="https://github.com/dwyl/learn-json-web-tokens/blob/master/README.md" target="_blank" rel="noopener noreferrer">Learn how to use JSON Web Tokens</a>, by dwyl</li></ul><p>（完）</p>`,62)]))}const r=a(p,[["render",o]]),c=JSON.parse('{"path":"/posts/frontend/JSON%20Web%20Token%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.html","title":"JSON Web Token 入门教程","lang":"en-US","frontmatter":{"date":"2025-07-11T00:00:00.000Z","category":["weekend"],"tag":["node","backend","frontend","jwt"]},"headers":[{"level":2,"title":"一、跨域认证的问题","slug":"一、跨域认证的问题","link":"#一、跨域认证的问题","children":[]},{"level":2,"title":"二、JWT 的原理","slug":"二、jwt-的原理","link":"#二、jwt-的原理","children":[]},{"level":2,"title":"三、JWT 的数据结构","slug":"三、jwt-的数据结构","link":"#三、jwt-的数据结构","children":[{"level":3,"title":"3.1 Header","slug":"_3-1-header","link":"#_3-1-header","children":[]},{"level":3,"title":"3.2 Payload","slug":"_3-2-payload","link":"#_3-2-payload","children":[]},{"level":3,"title":"3.3 Signature","slug":"_3-3-signature","link":"#_3-3-signature","children":[]},{"level":3,"title":"3.4 Base64URL","slug":"_3-4-base64url","link":"#_3-4-base64url","children":[]}]},{"level":2,"title":"四、JWT 的使用方式","slug":"四、jwt-的使用方式","link":"#四、jwt-的使用方式","children":[]},{"level":2,"title":"五、JWT 的几个特点","slug":"五、jwt-的几个特点","link":"#五、jwt-的几个特点","children":[]},{"level":2,"title":"六、参考链接","slug":"六、参考链接","link":"#六、参考链接","children":[]}],"git":{"updatedTime":1752246979000,"contributors":[{"name":"Tom-Lee-CN","username":"Tom-Lee-CN","email":"tomweichat@qq.com","commits":2,"url":"https://github.com/Tom-Lee-CN"}],"changelog":[{"hash":"fd63ff9a76b67a8ac64886a5b23b93cf47432bf4","time":1752246979000,"email":"tomweichat@qq.com","author":"Tom-Lee-CN","message":"新增NODE—Express接收文件_技术文档"},{"hash":"8d428f94ebfcda93c3a044c829c12a31c9eb29cc","time":1752246480000,"email":"tomweichat@qq.com","author":"Tom-Lee-CN","message":"新增一批技术文档"}]},"filePathRelative":"posts/frontend/JSON Web Token 入门教程.md","excerpt":"\\n<p>作者： <a href=\\"http://www.ruanyifeng.com/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">阮一峰</a></p>\\n<p>日期： <a href=\\"http://www.ruanyifeng.com/blog/2018/07/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">2018 年 7 月 23 日</a></p>\\n<p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案，本文介绍它的原理和用法。</p>\\n<p><img src=\\"https://cdn.beekka.com/blogimg/asset/201807/bg2018072301.jpg\\" alt=\\"img\\"></p>"}');export{r as comp,c as data};
