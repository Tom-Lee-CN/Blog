import{_ as s,c as a,d as t,o as p}from"./app-DCzuWk7c.js";const e={};function o(c,n){return p(),a("div",null,n[0]||(n[0]=[t(`<h1 id="javascript-运行机制详解-再谈-event-loop" tabindex="-1"><a class="header-anchor" href="#javascript-运行机制详解-再谈-event-loop"><span>JavaScript 运行机制详解：再谈 Event Loop</span></a></h1><p>我常常在各种场合被问到类似下面代码的输出顺序。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;start&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;setTimeout&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;promise&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;end&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你能毫不犹豫地答出 <code>start, end, promise, setTimeout</code>，并解释其原因，那么你对 JS 的异步机制已经有了不错的理解。如果你还有一丝困惑，希望本文能帮助你彻底梳理清楚。</p><p>这个问题的背后，是整个 JavaScript 的运行模型（runtime model），也就是我们常说的“事件循环”（Event Loop）。理解它，是前端工程师进阶的必经之路。</p><h2 id="为什么-javascript-是单线程" tabindex="-1"><a class="header-anchor" href="#为什么-javascript-是单线程"><span><strong>为什么 JavaScript 是单线程？</strong></span></a></h2><p>首先，我们必须记住一个基本事实：<strong>JavaScript 语言是一门单线程语言。</strong></p><p>这意味着，在任何一个时刻，JS 引擎只能执行一段代码。为什么这么设计？这与它的初衷有关。JavaScript 最初是为浏览器设计的，用于处理用户的交互，比如鼠标点击、键盘输入，以及操作 DOM。</p><p>试想一下，如果 JavaScript 是多线程的，会发生什么？一个线程要在一个 DOM 节点上增加内容，另一个线程要删除这个节点。那么浏览器应该听谁的？这会带来极其复杂的同步问题。为了避免这种复杂性，JavaScript 从诞生起就选择了单线程。</p><p>这既是它的优点，也是它的缺点。优点是简单，没有多线程的竞态、死锁等问题。缺点是，如果一个任务耗时很长，整个程序就会被“卡住”，无法响应其他操作。</p><h2 id="浏览器-一个多进程的-操作系统" tabindex="-1"><a class="header-anchor" href="#浏览器-一个多进程的-操作系统"><span><strong>浏览器：一个多进程的“操作系统”</strong></span></a></h2><p>“JS 是单线程的”这个说法其实不完全准确。准确来说，<strong>执行 JavaScript 代码的那个主线程是单线程的</strong>。</p><p>现代浏览器（以 Chrome 为例）本身是一个非常复杂的程序，它采用了多进程架构来保证稳定性和安全性。你可以打开 Chrome 的任务管理器（“更多工具” &gt; “任务管理器”）看看，通常会看到好几个进程：</p><blockquote><ul><li><strong>浏览器进程（Browser Process）</strong>：负责浏览器界面的“外壳”，比如地址栏、书签、前进后退按钮，以及协调其他进程。</li><li><strong>渲染进程（Renderer Process）</strong>：核心部分，负责将 HTML、CSS 和 JavaScript 转换成用户可以看到的网页。<strong>我们写的 JS 代码，主要就在这个进程的主线程（Main Thread）上运行</strong>。每个标签页通常会有一个独立的渲染进程。</li><li><strong>网络进程（Network Process）</strong>：负责处理网络请求，比如 <code>fetch</code>。</li><li><strong>GPU 进程（GPU Process）</strong>：负责处理 GPU 相关的任务，加速 3D 绘图和页面渲染。</li></ul></blockquote><p>这种设计的好处是隔离。一个标签页（渲染进程）崩溃了，不会影响到整个浏览器。</p><h2 id="任务队列-task-queue-和事件循环-event-loop" tabindex="-1"><a class="header-anchor" href="#任务队列-task-queue-和事件循环-event-loop"><span><strong>任务队列（Task Queue）和事件循环（Event Loop）</strong></span></a></h2><p>我们回到渲染进程的主线程。这个线程非常繁忙，它要做的事情包括：</p><ul><li>执行 JavaScript 代码</li><li>渲染页面布局（Layout）</li><li>绘制页面（Paint）</li><li>响应用户交互（Click, Scroll）</li></ul><p>如果所有任务都排队等着，一个耗时长的 JS 计算就会阻塞页面渲染和用户响应，这就是“假死”现象。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token comment">// 一个会让页面卡住的例子</span></span>
<span class="line">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;myButton&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 假装这是一个非常耗时的计算</span></span>
<span class="line">  <span class="token keyword">const</span> start <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">while</span> <span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 这5秒内，页面完全无法响应</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;计算完成!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了解决这个问题，浏览器引入了异步（asynchronous）执行模型。当遇到一些耗时操作（比如网络请求、定时器）时，主线程不会傻等，而是把这些任务“外包”给浏览器的其他线程（比如网络线程、定时器线程）。</p><p>这些“外包”任务完成后，会把一个“回调函数”（callback）放进一个叫做**任务队列（Task Queue）**的地方。主线程则继续执行自己手头的同步代码。</p><p>等到主线程的同步代码全部执行完毕，它就会去任务队列里看看，有没有需要执行的回调函数。如果有，就取出一个来执行。这个“<strong>主线程不断从任务队列里读取并执行任务</strong>”的过程，就叫做<strong>事件循环（Event Loop）</strong>。</p><p>这个模型可以用一张经典的图来表示：</p><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5b5acb5a7faa464a8e35c3e38b9a6a7c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbUNlbGw=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1755973738&amp;x-signature=wYd%2BF74%2BMBLFwWVODHfqNq6sGh0%3D" alt="019.jpg"></p><h2 id="微任务-microtask-和宏任务-macrotask" tabindex="-1"><a class="header-anchor" href="#微任务-microtask-和宏任务-macrotask"><span><strong>微任务（Microtask）和宏任务（Macrotask）</strong></span></a></h2><p>事情还没完。任务队列其实不止一个。根据 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.google.com%2Fsearch%3Fq%3Dhttps%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Fwebappapis.html%23event-loops" target="_blank" rel="noopener noreferrer">WHATWG 规范</a>，任务被分为两种类型：</p><ol><li><strong>宏任务（Macrotask，规范中称为 Task）</strong><ul><li><code>setTimeout</code>, <code>setInterval</code></li><li><code>script</code>（整体代码块）</li><li>I/O 操作, UI 渲染</li><li>用户交互事件（如 <code>click</code>, <code>scroll</code>）</li></ul></li><li><strong>微任务（Microtask）</strong><ul><li><code>Promise.then()</code>, <code>Promise.catch()</code>, <code>Promise.finally()</code></li><li><code>queueMicrotask()</code></li><li><code>MutationObserver</code></li></ul></li></ol><p>事件循环的规则是，<strong>优先级更高的是微任务</strong>。主线程在执行完一个宏任务后，并不是立刻去执行下一个宏任务，而是会检查微任务队列。</p><p><strong>完整的事件循环流程如下：</strong></p><ol><li>从宏任务队列中取出一个任务（通常是 <code>script</code> 脚本本身）并执行。</li><li>执行完毕后，检查微任务队列。</li><li>循环执行微任务队列中的所有任务，直到队列清空。</li><li>执行浏览器 UI 渲染（这一步不一定每次都会发生）。</li><li>回到第一步，从宏任务队列中取出下一个任务。</li></ol><p>这个“<strong>执行一个宏任务 -&gt; 清空所有微任务 -&gt; 再取下一个宏任务</strong>”的循环，是理解所有异步执行顺序的关键。</p><h2 id="回到最初的问题" tabindex="-1"><a class="header-anchor" href="#回到最初的问题"><span><strong>回到最初的问题</strong></span></a></h2><p>现在，我们用这个模型来分析开头的代码</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;start&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></span>
<span class="line"></span>
<span class="line"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 4</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;setTimeout&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 3</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;promise&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;end&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><strong>第一轮宏任务（script 脚本）开始执行。</strong><ul><li>遇到 <code>console.log(&#39;start&#39;)</code>，直接执行。输出 <code>start</code>。</li><li>遇到 <code>setTimeout</code>，它是一个宏任务。浏览器定时器线程接管，0ms 后将其回调函数推入<strong>宏任务队列</strong>。</li><li>遇到 <code>Promise.resolve().then()</code>，<code>.then()</code> 的回调是一个微任务。它被推入<strong>微任务队列</strong>。</li><li>遇到 <code>console.log(&#39;end&#39;)</code>，直接执行。输出 <code>end</code>。</li></ul></li><li><strong>第一个宏任务（script）执行完毕。</strong><ul><li>现在，事件循环会检查<strong>微任务队列</strong>。发现里面有一个任务（打印 <code>promise</code>）。</li><li>取出并执行该微任务。输出 <code>promise</code>。</li><li>微任务队列现在空了。</li></ul></li><li><strong>开始下一轮宏任务。</strong><ul><li>事件循环检查<strong>宏任务队列</strong>，发现 <code>setTimeout</code> 的回调函数在那里。</li><li>取出并执行该宏任务。输出 <code>setTimeout</code>。</li></ul></li></ol><p>至此，所有代码执行完毕。最终输出 <code>start, end, promise, setTimeout</code>。</p><h2 id="应用与思考" tabindex="-1"><a class="header-anchor" href="#应用与思考"><span><strong>应用与思考</strong></span></a></h2><p>理解了事件循环，很多问题就迎刃而解了。</p><ul><li><strong><code>setTimeout(fn, 0)</code> 为什么不是立即执行？</strong> 因为它只是把 <code>fn</code> 尽快地推入宏任务队列，但必须等到当前主线程的同步代码和所有微任务都执行完之后，才有机会被执行。</li><li><strong>页面为什么会卡顿？</strong> 通常是因为一个宏任务（比如一段 JS 计算或一个事件回调）执行时间过长，导致主线程无法脱身去处理其他宏任务（如 UI 渲染、用户点击）。</li><li><strong>如何处理耗时计算？</strong> 对于真正 CPU 密集的计算，应该使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWeb_Workers_API%2FUsing_web_workers" target="_blank" rel="noopener noreferrer">Web Worker</a>。它允许你在一个完全独立的后台线程中运行脚本，不会阻塞主线程。</li></ul><p>作者：mCell 链接：https://juejin.cn/post/7538701316909793299 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>`,41)]))}const i=s(e,[["render",o]]),u=JSON.parse('{"path":"/posts/frontend/JavaScript%20%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%86%8D%E8%B0%88%20Event%20Loop.html","title":"JavaScript 运行机制详解：再谈 Event Loop","lang":"en-US","frontmatter":{"date":"2025-08-18T00:00:00.000Z","category":["frontend"],"tag":["JavaScript","frontend"]},"headers":[{"level":2,"title":"为什么 JavaScript 是单线程？","slug":"为什么-javascript-是单线程","link":"#为什么-javascript-是单线程","children":[]},{"level":2,"title":"浏览器：一个多进程的“操作系统”","slug":"浏览器-一个多进程的-操作系统","link":"#浏览器-一个多进程的-操作系统","children":[]},{"level":2,"title":"任务队列（Task Queue）和事件循环（Event Loop）","slug":"任务队列-task-queue-和事件循环-event-loop","link":"#任务队列-task-queue-和事件循环-event-loop","children":[]},{"level":2,"title":"微任务（Microtask）和宏任务（Macrotask）","slug":"微任务-microtask-和宏任务-macrotask","link":"#微任务-microtask-和宏任务-macrotask","children":[]},{"level":2,"title":"回到最初的问题","slug":"回到最初的问题","link":"#回到最初的问题","children":[]},{"level":2,"title":"应用与思考","slug":"应用与思考","link":"#应用与思考","children":[]}],"git":{"updatedTime":1755531374000,"contributors":[{"name":"Tom-Lee-CN","username":"Tom-Lee-CN","email":"tomweichat@qq.com","commits":1,"url":"https://github.com/Tom-Lee-CN"}],"changelog":[{"hash":"3d57ad3db591c8d037366acc607925d0bc6264eb","time":1755531374000,"email":"tomweichat@qq.com","author":"Tom-Lee-CN","message":"new doc about event loop"}]},"filePathRelative":"posts/frontend/JavaScript 运行机制详解：再谈 Event Loop.md","excerpt":"\\n<p>我常常在各种场合被问到类似下面代码的输出顺序。</p>\\n<div class=\\"language-javascript line-numbers-mode\\" data-highlighter=\\"prismjs\\" data-ext=\\"js\\"><pre><code><span class=\\"line\\">console<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">log</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"start\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span></span>\\n<span class=\\"line\\"></span>\\n<span class=\\"line\\"><span class=\\"token function\\">setTimeout</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">function</span> <span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span></span>\\n<span class=\\"line\\">  console<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">log</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"setTimeout\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span></span>\\n<span class=\\"line\\"><span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span></span>\\n<span class=\\"line\\"></span>\\n<span class=\\"line\\">Promise<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">resolve</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">then</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">function</span> <span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span></span>\\n<span class=\\"line\\">  console<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">log</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"promise\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span></span>\\n<span class=\\"line\\"><span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span></span>\\n<span class=\\"line\\"></span>\\n<span class=\\"line\\">console<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">log</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"end\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span></span>\\n<span class=\\"line\\"></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>"}');export{i as comp,u as data};
