<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.20" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const useChoice = localStorage.getItem('vuepress-color-scheme')
      const systemStatus =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (useChoice === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (useChoice === 'dark' || systemStatus) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>JavaScript 运行机制详解：再谈 Event Loop | Tom`s Blog</title><meta name="description" content="欢迎来到Tom`s Blog">
    <link rel="preload" href="/Blog/assets/style-BhOYgqmK.css" as="style"><link rel="stylesheet" href="/Blog/assets/style-BhOYgqmK.css">
    <link rel="modulepreload" href="/Blog/assets/app-DCzuWk7c.js"><link rel="modulepreload" href="/Blog/assets/JavaScript 运行机制详解：再谈 Event Loop.html-DkZlOQHD.js">
    <link rel="prefetch" href="/Blog/assets/index.html-B7k01x-C.js" as="script"><link rel="prefetch" href="/Blog/assets/get-started.html-CoYxEMce.js" as="script"><link rel="prefetch" href="/Blog/assets/CORS跨域.html-CTTaRlK4.js" as="script"><link rel="prefetch" href="/Blog/assets/Express框架基础.html-BjZI7hiS.js" as="script"><link rel="prefetch" href="/Blog/assets/NODE与邮箱邮件发送.html-CKvUCzxc.js" as="script"><link rel="prefetch" href="/Blog/assets/NODE中使用UUID.html-C570vvHg.js" as="script"><link rel="prefetch" href="/Blog/assets/NODE原生HTTP.html-DuJevNd4.js" as="script"><link rel="prefetch" href="/Blog/assets/SEESION与JWT.html-Cp_LMYA9.js" as="script"><link rel="prefetch" href="/Blog/assets/nodeJs中间件Multer详解_使用express实现本地文件图片上传到服务器指定目录.html-BMAdKuVA.js" as="script"><link rel="prefetch" href="/Blog/assets/node与mysql.html-C_hp_f76.js" as="script"><link rel="prefetch" href="/Blog/assets/Cookie与Storage.html-BNpChu3u.js" as="script"><link rel="prefetch" href="/Blog/assets/Cookie的详细资料.html-BCdinKt4.js" as="script"><link rel="prefetch" href="/Blog/assets/Cookie的跨域传输.html-BnM3DKHw.js" as="script"><link rel="prefetch" href="/Blog/assets/Git的基本使用.html-BB7zqetM.js" as="script"><link rel="prefetch" href="/Blog/assets/JSON Web Token 入门教程.html-ChRaTT46.js" as="script"><link rel="prefetch" href="/Blog/assets/archive2.html-D3VkMMEI.js" as="script"><link rel="prefetch" href="/Blog/assets/sticky.html-KwhlfAgA.js" as="script"><link rel="prefetch" href="/Blog/assets/sticky2.html-D97ml3vl.js" as="script"><link rel="prefetch" href="/Blog/assets/CSS基础.html-C6xPccx4.js" as="script"><link rel="prefetch" href="/Blog/assets/Cookie与Storage.html-CiPrraFs.js" as="script"><link rel="prefetch" href="/Blog/assets/JS基础_JS执行环境_作用域(上下文).html-DV4qXHXU.js" as="script"><link rel="prefetch" href="/Blog/assets/Promise.html-VZrI4Fwz.js" as="script"><link rel="prefetch" href="/Blog/assets/localStorage、sessionStorage 与 Cookie_localstorage和sessionstorage和cookie-CSDN博客.html-DGh-an_E.js" as="script"><link rel="prefetch" href="/Blog/assets/pinia使用方法.html-BeVa1jiA.js" as="script"><link rel="prefetch" href="/Blog/assets/vue使用iFrame嵌入网页，网页等比缩放，全部展示.html--78FBJP2.js" as="script"><link rel="prefetch" href="/Blog/assets/为什么javascript开发人员应优先选择axios而不是fetch.html-ng4DcEnQ.js" as="script"><link rel="prefetch" href="/Blog/assets/前端必备技能：全面解析 Session 在 Web 开发中的应用.html-Ct0Jg0tR.js" as="script"><link rel="prefetch" href="/Blog/assets/原型与面向对象.html-kpY0MxNp.js" as="script"><link rel="prefetch" href="/Blog/assets/原生与Fetch的HTTP请求.html-871wP5S_.js" as="script"><link rel="prefetch" href="/Blog/assets/回调函数.html-Dpi7liwH.js" as="script"><link rel="prefetch" href="/Blog/assets/闭包与this指向和函数上下文调用.html-BmAHCHw_.js" as="script"><link rel="prefetch" href="/Blog/assets/404.html-DN2LvMvJ.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-Br0BV5Bh.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-B9k8afNY.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-iER2jIEU.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-Dp7I7S5j.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-DCeCWl9c.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-Gv6-Rnyf.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-O-6FDtP1.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-BWxfQTg4.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-2Zpu2e3F.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-2ti9-wGL.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-D9TaX6i0.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-MeuTJBSM.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-AmmiYiRF.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-CZrUYbgO.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-DJEZ83uT.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-D9WxIJQQ.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-Bo4dQKgJ.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-CUU6ft67.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-C6N32PFM.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-Bo4dQKgJ.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-az3hBZLk.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-CqCHUxV-.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-By6ENlB0.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-COpTSeFD.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-FrasgwFd.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-a3DEdIhz.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-Duruevod.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-zqKBFxIu.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-CNlKpVxN.js" as="script"><link rel="prefetch" href="/Blog/assets/index.html-CC4XyLxB.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/Blog/"><img class="vp-site-logo" src="https://vuejs.press/images/hero.png" alt="Tom`s Blog"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">Tom`s Blog</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/Blog/" aria-label="Home"><!--[--><!--[--><!--]--><!--]-->Home<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/Blog/article/" aria-label="文章"><!--[--><!--[--><!--]--><!--]-->文章<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/Blog/category/" aria-label="分类"><!--[--><!--[--><!--]--><!--]-->分类<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/Blog/tag/" aria-label="标签"><!--[--><!--[--><!--]--><!--]-->标签<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/Blog/timeline/" aria-label="最新"><!--[--><!--[--><!--]--><!--]-->最新<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/Blog/" aria-label="Home"><!--[--><!--[--><!--]--><!--]-->Home<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/Blog/article/" aria-label="文章"><!--[--><!--[--><!--]--><!--]-->文章<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/Blog/category/" aria-label="分类"><!--[--><!--[--><!--]--><!--]-->分类<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/Blog/tag/" aria-label="标签"><!--[--><!--[--><!--]--><!--]-->标签<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/Blog/timeline/" aria-label="最新"><!--[--><!--[--><!--]--><!--]-->最新<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">JavaScript 运行机制详解：再谈 Event Loop <!----></p><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div><h1 id="javascript-运行机制详解-再谈-event-loop" tabindex="-1"><a class="header-anchor" href="#javascript-运行机制详解-再谈-event-loop"><span>JavaScript 运行机制详解：再谈 Event Loop</span></a></h1><p>我常常在各种场合被问到类似下面代码的输出顺序。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;start&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;setTimeout&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;promise&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;end&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你能毫不犹豫地答出 <code>start, end, promise, setTimeout</code>，并解释其原因，那么你对 JS 的异步机制已经有了不错的理解。如果你还有一丝困惑，希望本文能帮助你彻底梳理清楚。</p><p>这个问题的背后，是整个 JavaScript 的运行模型（runtime model），也就是我们常说的“事件循环”（Event Loop）。理解它，是前端工程师进阶的必经之路。</p><h2 id="为什么-javascript-是单线程" tabindex="-1"><a class="header-anchor" href="#为什么-javascript-是单线程"><span><strong>为什么 JavaScript 是单线程？</strong></span></a></h2><p>首先，我们必须记住一个基本事实：<strong>JavaScript 语言是一门单线程语言。</strong></p><p>这意味着，在任何一个时刻，JS 引擎只能执行一段代码。为什么这么设计？这与它的初衷有关。JavaScript 最初是为浏览器设计的，用于处理用户的交互，比如鼠标点击、键盘输入，以及操作 DOM。</p><p>试想一下，如果 JavaScript 是多线程的，会发生什么？一个线程要在一个 DOM 节点上增加内容，另一个线程要删除这个节点。那么浏览器应该听谁的？这会带来极其复杂的同步问题。为了避免这种复杂性，JavaScript 从诞生起就选择了单线程。</p><p>这既是它的优点，也是它的缺点。优点是简单，没有多线程的竞态、死锁等问题。缺点是，如果一个任务耗时很长，整个程序就会被“卡住”，无法响应其他操作。</p><h2 id="浏览器-一个多进程的-操作系统" tabindex="-1"><a class="header-anchor" href="#浏览器-一个多进程的-操作系统"><span><strong>浏览器：一个多进程的“操作系统”</strong></span></a></h2><p>“JS 是单线程的”这个说法其实不完全准确。准确来说，<strong>执行 JavaScript 代码的那个主线程是单线程的</strong>。</p><p>现代浏览器（以 Chrome 为例）本身是一个非常复杂的程序，它采用了多进程架构来保证稳定性和安全性。你可以打开 Chrome 的任务管理器（“更多工具” &gt; “任务管理器”）看看，通常会看到好几个进程：</p><blockquote><ul><li><strong>浏览器进程（Browser Process）</strong>：负责浏览器界面的“外壳”，比如地址栏、书签、前进后退按钮，以及协调其他进程。</li><li><strong>渲染进程（Renderer Process）</strong>：核心部分，负责将 HTML、CSS 和 JavaScript 转换成用户可以看到的网页。<strong>我们写的 JS 代码，主要就在这个进程的主线程（Main Thread）上运行</strong>。每个标签页通常会有一个独立的渲染进程。</li><li><strong>网络进程（Network Process）</strong>：负责处理网络请求，比如 <code>fetch</code>。</li><li><strong>GPU 进程（GPU Process）</strong>：负责处理 GPU 相关的任务，加速 3D 绘图和页面渲染。</li></ul></blockquote><p>这种设计的好处是隔离。一个标签页（渲染进程）崩溃了，不会影响到整个浏览器。</p><h2 id="任务队列-task-queue-和事件循环-event-loop" tabindex="-1"><a class="header-anchor" href="#任务队列-task-queue-和事件循环-event-loop"><span><strong>任务队列（Task Queue）和事件循环（Event Loop）</strong></span></a></h2><p>我们回到渲染进程的主线程。这个线程非常繁忙，它要做的事情包括：</p><ul><li>执行 JavaScript 代码</li><li>渲染页面布局（Layout）</li><li>绘制页面（Paint）</li><li>响应用户交互（Click, Scroll）</li></ul><p>如果所有任务都排队等着，一个耗时长的 JS 计算就会阻塞页面渲染和用户响应，这就是“假死”现象。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token comment">// 一个会让页面卡住的例子</span></span>
<span class="line">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;myButton&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 假装这是一个非常耗时的计算</span></span>
<span class="line">  <span class="token keyword">const</span> start <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">while</span> <span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 这5秒内，页面完全无法响应</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;计算完成!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了解决这个问题，浏览器引入了异步（asynchronous）执行模型。当遇到一些耗时操作（比如网络请求、定时器）时，主线程不会傻等，而是把这些任务“外包”给浏览器的其他线程（比如网络线程、定时器线程）。</p><p>这些“外包”任务完成后，会把一个“回调函数”（callback）放进一个叫做**任务队列（Task Queue）**的地方。主线程则继续执行自己手头的同步代码。</p><p>等到主线程的同步代码全部执行完毕，它就会去任务队列里看看，有没有需要执行的回调函数。如果有，就取出一个来执行。这个“<strong>主线程不断从任务队列里读取并执行任务</strong>”的过程，就叫做<strong>事件循环（Event Loop）</strong>。</p><p>这个模型可以用一张经典的图来表示：</p><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5b5acb5a7faa464a8e35c3e38b9a6a7c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgbUNlbGw=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1755973738&amp;x-signature=wYd%2BF74%2BMBLFwWVODHfqNq6sGh0%3D" alt="019.jpg"></p><h2 id="微任务-microtask-和宏任务-macrotask" tabindex="-1"><a class="header-anchor" href="#微任务-microtask-和宏任务-macrotask"><span><strong>微任务（Microtask）和宏任务（Macrotask）</strong></span></a></h2><p>事情还没完。任务队列其实不止一个。根据 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.google.com%2Fsearch%3Fq%3Dhttps%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Fwebappapis.html%23event-loops" target="_blank" rel="noopener noreferrer">WHATWG 规范</a>，任务被分为两种类型：</p><ol><li><strong>宏任务（Macrotask，规范中称为 Task）</strong><ul><li><code>setTimeout</code>, <code>setInterval</code></li><li><code>script</code>（整体代码块）</li><li>I/O 操作, UI 渲染</li><li>用户交互事件（如 <code>click</code>, <code>scroll</code>）</li></ul></li><li><strong>微任务（Microtask）</strong><ul><li><code>Promise.then()</code>, <code>Promise.catch()</code>, <code>Promise.finally()</code></li><li><code>queueMicrotask()</code></li><li><code>MutationObserver</code></li></ul></li></ol><p>事件循环的规则是，<strong>优先级更高的是微任务</strong>。主线程在执行完一个宏任务后，并不是立刻去执行下一个宏任务，而是会检查微任务队列。</p><p><strong>完整的事件循环流程如下：</strong></p><ol><li>从宏任务队列中取出一个任务（通常是 <code>script</code> 脚本本身）并执行。</li><li>执行完毕后，检查微任务队列。</li><li>循环执行微任务队列中的所有任务，直到队列清空。</li><li>执行浏览器 UI 渲染（这一步不一定每次都会发生）。</li><li>回到第一步，从宏任务队列中取出下一个任务。</li></ol><p>这个“<strong>执行一个宏任务 -&gt; 清空所有微任务 -&gt; 再取下一个宏任务</strong>”的循环，是理解所有异步执行顺序的关键。</p><h2 id="回到最初的问题" tabindex="-1"><a class="header-anchor" href="#回到最初的问题"><span><strong>回到最初的问题</strong></span></a></h2><p>现在，我们用这个模型来分析开头的代码</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;start&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></span>
<span class="line"></span>
<span class="line"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 4</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;setTimeout&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 3</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;promise&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;end&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><strong>第一轮宏任务（script 脚本）开始执行。</strong><ul><li>遇到 <code>console.log(&#39;start&#39;)</code>，直接执行。输出 <code>start</code>。</li><li>遇到 <code>setTimeout</code>，它是一个宏任务。浏览器定时器线程接管，0ms 后将其回调函数推入<strong>宏任务队列</strong>。</li><li>遇到 <code>Promise.resolve().then()</code>，<code>.then()</code> 的回调是一个微任务。它被推入<strong>微任务队列</strong>。</li><li>遇到 <code>console.log(&#39;end&#39;)</code>，直接执行。输出 <code>end</code>。</li></ul></li><li><strong>第一个宏任务（script）执行完毕。</strong><ul><li>现在，事件循环会检查<strong>微任务队列</strong>。发现里面有一个任务（打印 <code>promise</code>）。</li><li>取出并执行该微任务。输出 <code>promise</code>。</li><li>微任务队列现在空了。</li></ul></li><li><strong>开始下一轮宏任务。</strong><ul><li>事件循环检查<strong>宏任务队列</strong>，发现 <code>setTimeout</code> 的回调函数在那里。</li><li>取出并执行该宏任务。输出 <code>setTimeout</code>。</li></ul></li></ol><p>至此，所有代码执行完毕。最终输出 <code>start, end, promise, setTimeout</code>。</p><h2 id="应用与思考" tabindex="-1"><a class="header-anchor" href="#应用与思考"><span><strong>应用与思考</strong></span></a></h2><p>理解了事件循环，很多问题就迎刃而解了。</p><ul><li><strong><code>setTimeout(fn, 0)</code> 为什么不是立即执行？</strong> 因为它只是把 <code>fn</code> 尽快地推入宏任务队列，但必须等到当前主线程的同步代码和所有微任务都执行完之后，才有机会被执行。</li><li><strong>页面为什么会卡顿？</strong> 通常是因为一个宏任务（比如一段 JS 计算或一个事件回调）执行时间过长，导致主线程无法脱身去处理其他宏任务（如 UI 渲染、用户点击）。</li><li><strong>如何处理耗时计算？</strong> 对于真正 CPU 密集的计算，应该使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWeb_Workers_API%2FUsing_web_workers" target="_blank" rel="noopener noreferrer">Web Worker</a>。它允许你在一个完全独立的后台线程中运行脚本，不会阻塞主线程。</li></ul><p>作者：mCell 链接：https://juejin.cn/post/7538701316909793299 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated:: </span><time class="meta-item-info" datetime="2025-08-18T15:36:14.000Z" data-allow-mismatch>8/18/25, 3:36 PM</time></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: tomweichat@qq.com">Tom-Lee-CN</span><!----><!--]--><!--]--></span></div></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/Blog/assets/app-DCzuWk7c.js" defer></script>
  </body>
</html>
